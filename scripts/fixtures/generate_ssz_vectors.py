#!/usr/bin/env python3
"""
Generate SSZ serialization vectors from the leanSpec reference implementation.

This script materializes a deterministic set of containers that match the
Devnet 0 structures and writes them to a C header so the unit tests can assert
Lantern's encoders/decoders against the reference encoding.
"""

from __future__ import annotations

import sys
from pathlib import Path
REPO_ROOT = Path(__file__).resolve().parents[2]
FIXTURE_DIR = REPO_ROOT / "tests" / "fixtures"
LEAN_SPEC_ROOT = REPO_ROOT / "tools" / "leanSpec"
LEAN_SPEC_SRC = LEAN_SPEC_ROOT / "src"
sys.path.insert(0, str(REPO_ROOT))
sys.path.insert(0, str(LEAN_SPEC_ROOT))
sys.path.insert(0, str(LEAN_SPEC_SRC))

from lean_spec.subspecs.containers.block import Block, BlockBody, BlockHeader, SignedBlock
from lean_spec.subspecs.containers.block.types import Attestations
from lean_spec.subspecs.containers.checkpoint import Checkpoint
from lean_spec.subspecs.containers.config import Config
from lean_spec.subspecs.containers.slot import Slot
from lean_spec.subspecs.containers.state import State
from lean_spec.subspecs.containers.state.types import (
    HistoricalBlockHashes,
    JustificationRoots,
    JustificationValidators,
    JustifiedSlots,
)
from lean_spec.subspecs.containers.vote import SignedVote, Vote
from lean_spec.subspecs.ssz.hash import hash_tree_root
from lean_spec.types import Bytes32, Uint64
from lean_spec.types.boolean import Boolean

HEADER_TEMPLATE = """\
/* Autogenerated by generate_ssz_vectors.py â€” do not edit manually. */
#ifndef LANTERN_TESTS_SSZ_VECTORS_H
#define LANTERN_TESTS_SSZ_VECTORS_H

#include <stdint.h>

/* The arrays below are derived from leanSpec/src using the reference SSZ
 * implementation. They ensure Lantern stays byte-for-byte compatible with the
 * Devnet 0 containers defined in leanSpec/docs/client/containers.md. */
{body}

#endif /* LANTERN_TESTS_SSZ_VECTORS_H */
"""


def bytes32_from_seed(seed: int) -> Bytes32:
    """Return a Bytes32 whose contents increment from the supplied seed."""
    return Bytes32(bytes((seed + i) % 256 for i in range(Bytes32.LENGTH)))


def format_u8_array(name: str, data: bytes, indent: str = "    ") -> str:
    lines = [f"static const uint8_t {name}[] = {{\n"]
    for index in range(0, len(data), 12):
        chunk = ", ".join(f"0x{byte:02X}" for byte in data[index : index + 12])
        suffix = "," if index + 12 < len(data) else ""
        lines.append(f"{indent}{chunk}{suffix}\n")
    if not data:
        lines.append(f"{indent}\n")
    lines.append("};\n")
    return "".join(lines)


def format_u64_macro(name: str, value: int) -> str:
    return f"#define {name} UINT64_C({value})\n"


def main() -> None:
    header_path = FIXTURE_DIR / "ssz_vectors.h"

    # Deterministic consensus config.
    num_validators = Uint64(4)
    genesis_time = Uint64(1_700_000_000)
    config = Config(num_validators=num_validators, genesis_time=genesis_time)

    # Helper checkpoints reused across containers.
    checkpoint_justified = Checkpoint(root=bytes32_from_seed(0x30), slot=Slot(5))
    checkpoint_finalized = Checkpoint(root=bytes32_from_seed(0x40), slot=Slot(4))

    head_checkpoint = Checkpoint(root=bytes32_from_seed(0x50), slot=Slot(6))
    target_checkpoint = Checkpoint(root=bytes32_from_seed(0x60), slot=Slot(5))
    source_checkpoint = Checkpoint(root=bytes32_from_seed(0x70), slot=Slot(4))

    second_head_checkpoint = Checkpoint(root=bytes32_from_seed(0x80), slot=Slot(8))
    second_target_checkpoint = Checkpoint(root=bytes32_from_seed(0x90), slot=Slot(7))
    second_source_checkpoint = Checkpoint(root=bytes32_from_seed(0xA0), slot=Slot(6))

    vote_a = Vote(
        validator_id=Uint64(1),
        slot=Slot(6),
        head=head_checkpoint,
        target=target_checkpoint,
        source=source_checkpoint,
    )
    vote_b = Vote(
        validator_id=Uint64(3),
        slot=Slot(7),
        head=second_head_checkpoint,
        target=second_target_checkpoint,
        source=second_source_checkpoint,
    )

    signed_vote_a = SignedVote(data=vote_a, signature=Bytes32.zero())

    signed_vote_b = SignedVote(data=vote_b, signature=Bytes32.zero())

    attestations = Attestations(data=[signed_vote_a, signed_vote_b])
    block_body = BlockBody(attestations=attestations)

    body_root = hash_tree_root(block_body)

    block_header = BlockHeader(
        slot=Slot(9),
        proposer_index=Uint64(2),
        parent_root=bytes32_from_seed(0xB0),
        state_root=bytes32_from_seed(0xC0),
        body_root=body_root,
    )

    block = Block(
        slot=block_header.slot,
        proposer_index=block_header.proposer_index,
        parent_root=block_header.parent_root,
        state_root=block_header.state_root,
        body=block_body,
    )

    signed_block = SignedBlock(message=block, signature=Bytes32.zero())

    historical_roots = HistoricalBlockHashes(
        data=[bytes32_from_seed(0xD0), bytes32_from_seed(0xE0)]
    )
    justified_slots = JustifiedSlots(
        data=[Boolean(True), Boolean(False), Boolean(True), Boolean(True)]
    )
    justification_roots = JustificationRoots(
        data=[bytes32_from_seed(0xF0)]
    )
    justification_validators = JustificationValidators(
        data=[
            Boolean(True),
            Boolean(False),
            Boolean(True),
            Boolean(False),
        ]
    )

    state = State(
        config=config,
        slot=Slot(9),
        latest_block_header=block_header,
        latest_justified=checkpoint_justified,
        latest_finalized=checkpoint_finalized,
        historical_block_hashes=historical_roots,
        justified_slots=justified_slots,
        justifications_roots=justification_roots,
        justifications_validators=justification_validators,
    )

    parts: list[str] = []

    # Config metadata
    parts.append(format_u64_macro("LANTERN_VECTOR_CONFIG_NUM_VALIDATORS", num_validators.as_int()))
    parts.append(format_u64_macro("LANTERN_VECTOR_CONFIG_GENESIS_TIME", genesis_time.as_int()))
    parts.append(format_u8_array("LANTERN_SSZ_VECTOR_CONFIG", config.encode_bytes()))

    # Checkpoints
    for label, checkpoint in (
        ("CHECKPOINT_JUSTIFIED", checkpoint_justified),
        ("CHECKPOINT_FINALIZED", checkpoint_finalized),
        ("CHECKPOINT_HEAD_A", head_checkpoint),
        ("CHECKPOINT_TARGET_A", target_checkpoint),
        ("CHECKPOINT_SOURCE_A", source_checkpoint),
        ("CHECKPOINT_HEAD_B", second_head_checkpoint),
        ("CHECKPOINT_TARGET_B", second_target_checkpoint),
        ("CHECKPOINT_SOURCE_B", second_source_checkpoint),
    ):
        parts.append(format_u64_macro(f"LANTERN_VECTOR_{label}_SLOT", checkpoint.slot.as_int()))
        parts.append(format_u8_array(f"LANTERN_VECTOR_{label}_ROOT", bytes(checkpoint.root)))
        parts.append(format_u8_array(f"LANTERN_SSZ_VECTOR_{label}", checkpoint.encode_bytes()))

    # Votes and signed votes
    for label, vote in (("VOTE_A", vote_a), ("VOTE_B", vote_b)):
        parts.append(format_u64_macro(f"LANTERN_VECTOR_{label}_VALIDATOR_ID", vote.validator_id.as_int()))
        parts.append(format_u64_macro(f"LANTERN_VECTOR_{label}_SLOT", vote.slot.as_int()))
        parts.append(format_u8_array(f"LANTERN_VECTOR_{label}_HEAD_ROOT", bytes(vote.head.root)))
        parts.append(format_u64_macro(f"LANTERN_VECTOR_{label}_HEAD_SLOT", vote.head.slot.as_int()))
        parts.append(format_u8_array(f"LANTERN_VECTOR_{label}_TARGET_ROOT", bytes(vote.target.root)))
        parts.append(format_u64_macro(f"LANTERN_VECTOR_{label}_TARGET_SLOT", vote.target.slot.as_int()))
        parts.append(format_u8_array(f"LANTERN_VECTOR_{label}_SOURCE_ROOT", bytes(vote.source.root)))
        parts.append(format_u64_macro(f"LANTERN_VECTOR_{label}_SOURCE_SLOT", vote.source.slot.as_int()))
        parts.append(format_u8_array(f"LANTERN_SSZ_VECTOR_{label}", vote.encode_bytes()))

    for label, signed_vote in (("SIGNED_VOTE_A", signed_vote_a), ("SIGNED_VOTE_B", signed_vote_b)):
        parts.append(format_u8_array(f"LANTERN_SSZ_VECTOR_{label}", signed_vote.encode_bytes()))

    # Block metadata
    parts.append(format_u64_macro("LANTERN_VECTOR_BLOCK_HEADER_SLOT", block_header.slot.as_int()))
    parts.append(format_u64_macro("LANTERN_VECTOR_BLOCK_HEADER_PROPOSER", block_header.proposer_index.as_int()))
    parts.append(format_u8_array("LANTERN_VECTOR_BLOCK_HEADER_PARENT_ROOT", bytes(block_header.parent_root)))
    parts.append(format_u8_array("LANTERN_VECTOR_BLOCK_HEADER_STATE_ROOT", bytes(block_header.state_root)))
    parts.append(format_u8_array("LANTERN_VECTOR_BLOCK_HEADER_BODY_ROOT", bytes(block_header.body_root)))
    parts.append(format_u8_array("LANTERN_SSZ_VECTOR_BLOCK_HEADER", block_header.encode_bytes()))

    parts.append(format_u8_array("LANTERN_SSZ_VECTOR_BLOCK_BODY", block_body.encode_bytes()))
    parts.append(format_u8_array("LANTERN_SSZ_VECTOR_BLOCK", block.encode_bytes()))
    parts.append(format_u8_array("LANTERN_SSZ_VECTOR_SIGNED_BLOCK", signed_block.encode_bytes()))

    # Block body metadata
    parts.append("#define LANTERN_VECTOR_BLOCK_BODY_ATTESTATION_COUNT 2u\n")

    # State metadata
    parts.append(format_u64_macro("LANTERN_VECTOR_STATE_SLOT", state.slot.as_int()))
    parts.append("#define LANTERN_VECTOR_STATE_HISTORICAL_ROOTS_COUNT 2u\n")
    parts.append(format_u8_array("LANTERN_VECTOR_STATE_HISTORICAL_ROOT_0", bytes(historical_roots.data[0])))
    parts.append(format_u8_array("LANTERN_VECTOR_STATE_HISTORICAL_ROOT_1", bytes(historical_roots.data[1])))

    justified_slots_bytes = justified_slots.encode_bytes()
    parts.append("#define LANTERN_VECTOR_STATE_JUSTIFIED_SLOTS_BITS 4u\n")
    parts.append(format_u8_array("LANTERN_VECTOR_STATE_JUSTIFIED_SLOTS_BYTES", justified_slots_bytes))

    parts.append("#define LANTERN_VECTOR_STATE_JUSTIFICATION_ROOTS_COUNT 1u\n")
    parts.append(format_u8_array("LANTERN_VECTOR_STATE_JUSTIFICATION_ROOT_0", bytes(justification_roots.data[0])))

    justification_validators_bytes = justification_validators.encode_bytes()
    parts.append("#define LANTERN_VECTOR_STATE_JUSTIFICATION_VALIDATORS_BITS 4u\n")
    parts.append(
        format_u8_array(
            "LANTERN_VECTOR_STATE_JUSTIFICATION_VALIDATORS_BYTES",
            justification_validators_bytes,
        )
    )

    parts.append(format_u8_array("LANTERN_SSZ_VECTOR_STATE", state.encode_bytes()))

    header_body = "\n".join(parts)
    header_path.write_text(HEADER_TEMPLATE.format(body=header_body))


if __name__ == "__main__":
    main()
